<html
  xmlns:v="urn:schemas-microsoft-com:vml"
  xmlns:o="urn:schemas-microsoft-com:office:office"
  xmlns:w="urn:schemas-microsoft-com:office:word"
  xmlns:st1="urn:schemas-microsoft-com:office:smarttags"
  xmlns="http://www.w3.org/TR/REC-html40"
>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
    <meta name="ProgId" content="Word.Document" />
    <meta name="Generator" content="Microsoft Word 11" />
    <meta name="Originator" content="Microsoft Word 11" />
    <link rel="File-List" href="s_chapter3.files/filelist.xml" />
    <link rel="Edit-Time-Data" href="s_chapter3.files/editdata.mso" />
    <!--[if !mso]>
      <style>
        v\:* {
          behavior: url(#default#VML);
        }
        o\:* {
          behavior: url(#default#VML);
        }
        w\:* {
          behavior: url(#default#VML);
        }
        .shape {
          behavior: url(#default#VML);
        }
      </style>
    <![endif]-->
    <title>
      Introduction to Automata Theory, Languages, and Computation: Solutions for
      Chapter 3
    </title>
    <o:SmartTagType
      namespaceuri="urn:schemas-microsoft-com:office:smarttags"
      name="chsdate"
    />
    <!--[if gte mso 9
      ]><xml>
        <o:DocumentProperties>
          <o:Author>wang</o:Author>
          <o:Template>Normal</o:Template>
          <o:LastAuthor>wangshengyuan</o:LastAuthor>
          <o:Revision>7</o:Revision>
          <o:TotalTime>3</o:TotalTime>
          <o:Created>2002-01-23T01:41:00Z</o:Created>
          <o:LastSaved>2011-11-19T08:13:00Z</o:LastSaved>
          <o:Pages>3</o:Pages>
          <o:Words>764</o:Words>
          <o:Characters>4357</o:Characters>
          <o:Company>wyy</o:Company>
          <o:Lines>36</o:Lines>
          <o:Paragraphs>10</o:Paragraphs>
          <o:CharactersWithSpaces>5111</o:CharactersWithSpaces>
          <o:Version>11.9999</o:Version>
        </o:DocumentProperties>
      </xml><!
    [endif]-->
    <!--[if gte mso 9
      ]><xml>
        <w:WordDocument>
          <w:SpellingState>Clean</w:SpellingState>
          <w:GrammarState>Clean</w:GrammarState>
          <w:DrawingGridVerticalSpacing>7.8 ��</w:DrawingGridVerticalSpacing>
          <w:ValidateAgainstSchemas />
          <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
          <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
          <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
          <w:Compatibility>
            <w:UseFELayout />
          </w:Compatibility>
          <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
        </w:WordDocument>
      </xml><!
    [endif]-->
    <!--[if gte mso 9
      ]><xml>
        <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
        </w:LatentStyles> </xml
    ><![endif]-->
    <!--[if !mso
      ]><object
        classid="clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D"
        id="ieooui"
      ></object>
      <style>
        st1\:* {
          behavior: url(#ieooui);
        }
      </style>
    <![endif]-->
    <style>
      <!--
       /* Font Definitions */
       @font-face
      	{font-family: "Cambria Math";
      	panose-1:2 1 6 0 3 1 1 1 1 1;
      	mso-font-alt:SimSun;
      	mso-font-charset:134;
      	mso-generic-font-family:auto;
      	mso-font-pitch:variable;
      	mso-font-signature:3 135135232 16 0 262145 0;}
      @font-face
      	{font-family:"Cambria Math";
      	panose-1:2 1 6 0 3 1 1 1 1 1;
      	mso-font-charset:134;
      	mso-generic-font-family:auto;
      	mso-font-pitch:variable;
      	mso-font-signature:3 135135232 16 0 262145 0;}
       /* Style Definitions */
       p.MsoNormal, li.MsoNormal, div.MsoNormal
      	{mso-style-parent:"";
      	margin:0cm;
      	margin-bottom:.0001pt;
      	mso-pagination:widow-orphan;
      	font-size:12.0pt;
      	font-family: "Cambria Math";
      	mso-bidi-font-family:"Geneva";}
      a:link, span.MsoHyperlink
      	{color:blue;
      	text-decoration:underline;
      	text-underline:single;}
      a:visited, span.MsoHyperlinkFollowed
      	{color:blue;
      	text-decoration:underline;
      	text-underline:single;}
      p
      	{mso-margin-top-alt:auto;
      	margin-right:0cm;
      	mso-margin-bottom-alt:auto;
      	margin-left:0cm;
      	mso-pagination:widow-orphan;
      	font-size:12.0pt;
      	font-family: "Cambria Math";
      	mso-bidi-font-family:"Geneva";}
      span.SpellE
      	{mso-style-name:"";
      	mso-spl-e:yes;}
      span.GramE
      	{mso-style-name:"";
      	mso-gram-e:yes;}
       /* Page Definitions */
       @page
      	{mso-page-border-surround-header:no;
      	mso-page-border-surround-footer:no;}
      @page Section1
      	{size:595.3pt 841.9pt;
      	margin:72.0pt 90.0pt 72.0pt 90.0pt;
      	mso-header-margin:42.55pt;
      	mso-footer-margin:49.6pt;
      	mso-paper-source:0;}
      div.Section1
      	{page:Section1;}
      -->
    </style>
    <!--[if gte mso 10]>
      <style>
        /* Style Definitions */
        table.MsoNormalTable {
          mso-style-name: ��ͨCambria Math;
          mso-tstyle-rowband-size: 0;
          mso-tstyle-colband-size: 0;
          mso-style-noshow: yes;
          mso-style-parent: "";
          mso-padding-alt: 0cm 5.4pt 0cm 5.4pt;
          mso-para-margin: 0cm;
          mso-para-margin-bottom: 0.0001pt;
          mso-pagination: widow-orphan;
          font-size: 10pt;
          font-family: "Geneva";
          mso-fareast-font-family: "Geneva";
          mso-ansi-language: #0400;
          mso-fareast-language: #0400;
          mso-bidi-language: #0400;
        }
      </style>
    <![endif]-->
    <!--[if gte mso 9
      ]><xml> <o:shapedefaults v:ext="edit" spidmax="1026" /> </xml
    ><![endif]-->
    <!--[if gte mso 9
      ]><xml>
        <o:shapelayout v:ext="edit">
          <o:idmap v:ext="edit" data="1" /> </o:shapelayout></xml
    ><![endif]-->
  </head>

  <body
    bgcolor="black"
    lang="ZH-CN"
    link="blue"
    vlink="blue"
    text="white"
    style="tab-interval: 21pt"
  >
    <div class="Section1">
      <div align="center">
        <table
          class="MsoNormalTable"
          border="0"
          cellpadding="0"
          style="mso-cellspacing: 1.5pt; mso-padding-alt: 0cm 0cm 0cm 0cm"
        >
          <tr
            style="
              mso-yfti-irow: 0;
              mso-yfti-firstrow: yes;
              mso-yfti-lastrow: yes;
            "
          >
            <td style="padding: 0.75pt 0.75pt 0.75pt 0.75pt">
              <p class="MsoNormal">
                <span lang="EN-US"><o:p>&nbsp;</o:p></span>
              </p>
            </td>
            <td style="padding: 0.75pt 0.75pt 0.75pt 0.75pt">
              <p class="MsoNormal" align="center" style="text-align: center">
                <span lang="EN-US" style="font-size: 24pt"
                  >Introduction to Automata Theory, Languages, and
                  Computation</span
                ><span lang="EN-US"> </span>
              </p>
            </td>
          </tr>
        </table>
      </div>

      <h2 align="center" style="text-align: center">
        <a name="top"></a><span lang="EN-US">Solutions for Chapter 3</span>
      </h2>

      <p>
        <span lang="EN-US"><span style="mso-spacerun: yes">&nbsp;</span></span>
      </p>

      <h2>
        <a name="sol31"></a><span lang="EN-US">Solutions for Section 3.1</span>
      </h2>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.1.1</st1:chsdate
          >(a)</span
        >
      </h3>

      <p class="MsoNormal">
        <span lang="EN-US"
          >The simplest approach is to consider those strings in which the first
          <span class="GramE"><i>a</i> precedes</span> the first
          <i>b</i> separately from those where the opposite occurs. The
          expression:
          <b
            >c*<span class="GramE">a(</span
            ><span class="SpellE">a+c</span>)*b(<span class="SpellE">a+b+c</span
            >)* + c*b(<span class="SpellE">b+c</span>)*a(<span class="SpellE"
              >a+b+c</span
            >)*</b
          >
        </span>
      </p>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.1.2</st1:chsdate
          >(a)</span
        >
      </h3>

      <p class="MsoNormal">
        <span lang="EN-US"
          >The trick is to start by writing an expression for the set of strings
          that have no two adjacent 1's. Here is one such expression:
          <b>(10+0)*(</b>epsilon<b>+1)</b>
        </span>
      </p>

      <p>
        <span lang="EN-US"
          >To see why this expression works, the first part consists of all
          strings in which every 1 is followed by a 0. To that, we have only to
          add the possibility that there is a 1 at the end, which will not be
          followed by a 0. That is the job
          <span class="SpellE">os</span> (epsilon+1).
        </span>
      </p>

      <p>
        <span lang="EN-US"
          >Now, we can rethink the question as asking for strings that have a
          prefix with no adjacent 1's followed by a suffix with
          <span class="GramE">no</span> adjacent 0's. The former is the
          expression we developed, and the latter is the same expression, with 0
          and 1 interchanged. Thus, a solution to this problem is
          <b>(10+0)*(</b>epsilon<b>+1<span class="GramE">)(</span>01+1)*(</b
          >epsilon<b>+0)</b>
        </span>
      </p>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.1.4</st1:chsdate
          >(a)</span
        >
      </h3>

      <p class="MsoNormal">
        <span lang="EN-US"
          >This expression is another way to write ``no adjacent 1's.'' You
          should compare it with the different-looking expression we developed
          in the solution to Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.1.2</st1:chsdate
          >(a). The argument for why it works is similar. <b>(00*1)*</b> says
          every 1 is preceded by at least one 0. <b>0*</b> at the end allows 0's
          after the final 1, and (epsilon+<b>1</b>) at the beginning allows an
          initial 1, which must be either the only symbol of the string or
          followed by a 0.
        </span>
      </p>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.1.5</st1:chsdate
          ></span
        >
      </h3>

      <p class="MsoNormal">
        <span class="GramE"
          ><span lang="EN-US"
            >The language of the regular expression epsilon.</span
          ></span
        ><span lang="EN-US">
          Note that epsilon* denotes the language of strings consisting of any
          number of empty strings, concatenated, but that is just the set
          containing the empty string.
        </span>
      </p>

      <p>
        <span lang="EN-US"><o:p>&nbsp;</o:p></span>
      </p>

      <h2>
        <a name="sol32"></a><span lang="EN-US">Solutions for Section 3.2</span>
      </h2>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.2.1</st1:chsdate
          ></span
        >
      </h3>

      <p class="MsoNormal">
        <span lang="EN-US"
          >Part (a): The following are all R<span class="GramE">^(</span>0)
          expressions; we list only the subscripts. </span
        ><span lang="PT-BR" style="mso-ansi-language: PT-BR"
          >R11 = epsilon+<b>1</b>; R12 = <b>0</b>; R13 = phi; R21 = <b>1</b>;
          R22 = epsilon; R23 = <b>0</b>; R31 = phi; R32 = <b>1</b>; R33 =
          epsilon+<b>0</b>. <o:p></o:p
        ></span>
      </p>

      <p>
        <span lang="EN-US"
          >Part (b): Here all expression names are R<span class="GramE">^(</span
          >1); we again list only the subscripts. </span
        ><span lang="PT-BR" style="mso-ansi-language: PT-BR"
          >R11 = <b>1</b>*; R12 = <b>1*0</b>; R13 = phi; R21 = <b>11*</b>; R22 =
          epsilon+<b>11*0</b>; R23 = <b>0</b>; R31 = phi; R32 = <b>1</b>; R33 =
          epsilon+<b>0</b>. <o:p></o:p
        ></span>
      </p>

      <p>
        <span lang="EN-US">Part (e): Here is the transition diagram: </span>
      </p>

      <p>
        <span lang="EN-US"
          ><img
            width="236"
            height="89"
            id="_x0000_i1026"
            src="Introduction%20to%20Automata%20Theory,%20Languages,%20and%20Computation%20Solutions%20for%20Chapter%203.files/321.gif"
            border="0"
        /></span>
      </p>

      <p>
        <span lang="EN-US">If we eliminate state <i>q2</i> we get: </span>
      </p>

      <p>
        <span lang="EN-US"
          ><img
            width="197"
            height="94"
            id="_x0000_i1027"
            src="Introduction%20to%20Automata%20Theory,%20Languages,%20and%20Computation%20Solutions%20for%20Chapter%203.files/321a.gif"
            border="0"
        /></span>
      </p>

      <p>
        <span lang="EN-US"
          >Applying the formula in the text, the expression for the ways to get
          from <i>q1</i> to <i>q3</i> is:
          <b>[1 + 01 + 00(0+10)*11]*00(0+10)*</b>
        </span>
      </p>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.2.4</st1:chsdate
          >(a)</span
        >
      </h3>

      <p class="MsoNormal">
        <span lang="EN-US"
          ><img
            width="246"
            height="71"
            id="_x0000_i1028"
            src="Introduction%20to%20Automata%20Theory,%20Languages,%20and%20Computation%20Solutions%20for%20Chapter%203.files/324.gif"
            border="0"
        /></span>
      </p>

      <h3>
        <span lang="PT-BR" style="mso-ansi-language: PT-BR"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.2.6</st1:chsdate
          >(a)<o:p></o:p
        ></span>
      </h3>

      <p class="MsoNormal">
        <i><span lang="PT-BR" style="mso-ansi-language: PT-BR">L</span></i
        ><span lang="PT-BR" style="mso-ansi-language: PT-BR"
          >* <o:p></o:p
        ></span>
      </p>

      <h3>
        <span lang="PT-BR" style="mso-ansi-language: PT-BR"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.2.6</st1:chsdate
          >(b)<o:p></o:p
        ></span>
      </h3>

      <p class="MsoNormal">
        <span class="GramE"
          ><span lang="EN-US"
            >The set of suffixes of strings in <i>L</i>.</span
          ></span
        ><span lang="EN-US"> </span>
      </p>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.2.8</st1:chsdate
          ></span
        >
      </h3>

      <p class="MsoNormal">
        <span lang="EN-US"
          >Let
          <i
            >R<span class="GramE">^(</span>k)_<span class="SpellE">ijm</span></i
          >
          be the number of paths from state
          <span class="SpellE"><i>i</i></span> to state <i>j</i> of length
          <i>m</i> that go through no state numbered higher than <i>k</i>. We
          can compute these numbers, for all states
          <span class="SpellE"><i>i</i></span> and <i>j</i>, and for <i>m</i> no
          greater than <i>n</i>, by induction on <i>k</i>.
        </span>
      </p>

      <p>
        <span lang="EN-US"
          >Basis: <i>R<span class="GramE">^(</span>0)_ij1</i> is the number of
          arcs (or more precisely, arc labels) from state
          <span class="SpellE"><i>i</i></span> to state <i>j</i>.
          <i>R^(0)_ii0</i> = 1, and all other
          <i
            >R^(0)_<span class="SpellE"
              >ijm<span style="font-style: normal">'s</span></span
            ></i
          >
          are 0.
        </span>
      </p>

      <p>
        <span lang="EN-US"
          >Induction: <i>R^(k)_<span class="SpellE">ijm</span></i> is the sum of
          <i>R^(k-1)_<span class="SpellE">ijm</span></i> and the sum over all
          lists <i>(p1,p2,...,pr)</i> of positive integers that sum to <i>m</i>,
          of
          <i
            >R^(k-1)_ikp1 * R^(k-1)_kkp2 *R^(k-1)_kkp3 *...* R^(k-1)_<span
              class="SpellE"
              >kkp</span
            >(r-1) * R^(k-1)_<span class="SpellE">kjpr</span></i
          >. Note <i>r</i> must be at least 2.
        </span>
      </p>

      <p>
        <span lang="EN-US"
          >The answer is the sum of <i>R<span class="GramE">^(</span>k)_1jn</i>,
          where <i>k</i> is the number of states, 1 is the start state, and
          <i>j</i> is any accepting state.
        </span>
      </p>

      <p>
        <span lang="EN-US"><o:p>&nbsp;</o:p></span>
      </p>

      <h2>
        <a name="sol34"></a><span lang="EN-US">Solutions for Section 3.4</span>
      </h2>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.4.1</st1:chsdate
          >(a)</span
        >
      </h3>

      <p class="MsoNormal">
        <span lang="EN-US"
          >Replace <i>R</i> by <i>{a}</i> and <i>S</i> by <i>{b}</i>. Then the
          left and right sides become <i>{a} union {b} = {b} union {a}</i>. That
          is,
          <i
            >{<span class="SpellE">a<span class="GramE">,b</span></span
            >} = {<span class="SpellE">b,a</span>}</i
          >. Since order is irrelevant in sets, both languages are the same: the
          language consisting of the strings
          <span class="GramE"><i>a</i> and</span> <i>b</i>.
        </span>
      </p>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.4.1</st1:chsdate
          >(f)</span
        >
      </h3>

      <p class="MsoNormal">
        <span lang="EN-US"
          >Replace <i>R</i> by <i>{a}</i>. The right side becomes <i>{a}*</i>,
          that is, all strings of
          <span class="SpellE"
            ><span class="GramE"><i>a</i>'s</span></span
          >, including the empty string. The left side is <i>({a}*)*</i>, that
          is, all strings consisting of the concatenation of strings of
          <span class="SpellE"><i>a</i>'s</span>. But that is just the set of
          strings of
          <span class="SpellE"
            ><span class="GramE"><i>a</i>'s</span></span
          >, and is therefore equal to the right side.
        </span>
      </p>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.4.2</st1:chsdate
          >(a)</span
        >
      </h3>

      <p class="MsoNormal">
        <span lang="EN-US"
          >Not the same. Replace <i>R</i> by <i>{a}</i> and <i>S</i> by
          <i>{b}</i>. The left side becomes all strings of
          <span class="SpellE"><i>a</i>'s</span> and
          <span class="SpellE"><i>b</i>'s</span> (mixed), while the right side
          consists only of strings of
          <span class="SpellE"
            ><span class="GramE"><i>a</i>'s</span></span
          >
          (alone) and strings of <span class="SpellE"><i>b</i>'s</span> (alone).
          A string like <span class="SpellE"><i>ab</i></span> is in the language
          of the left side but not the right.
        </span>
      </p>

      <h3>
        <span lang="EN-US"
          >Exercise
          <st1:chsdate
            IsROCDate="False"
            IsLunarDate="False"
            Day="30"
            Month="12"
            Year="1899"
            w:st="on"
            >3.4.2</st1:chsdate
          >(c)</span
        >
      </h3>

      <p class="MsoNormal">
        <span class="GramE"><span lang="EN-US">Also not the same.</span></span
        ><span lang="EN-US">
          Replace <i>R</i> by <i>{a}</i> and <i>S</i> by <i>{b}</i>. The right
          side consists of all strings composed of zero or more occurrences of
          strings of the form <i>a...<span class="SpellE">ab</span></i
          >, that is, one or more <span class="SpellE"><i>a</i>'s</span> ended
          by one <i>b</i>. However, every string in the language of the left
          side has to end in <i>ab</i>. Thus, for instance, <i>epsilon</i> is in
          the language on the right, but not on the left.
        </span>
      </p>

      <p>
        <span lang="EN-US"
          ><a href="solutions.htm">Return to Home</a><i><o:p></o:p></i
        ></span>
      </p>

      <p>
        <span lang="EN-US"><o:p>&nbsp;</o:p></span>
      </p>
    </div>
  </body>
</html>
